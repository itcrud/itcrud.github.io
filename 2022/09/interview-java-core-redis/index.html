<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java问答知识总结篇-Redis, 程序猿洞晓">
    <meta name="description" content="以问答的方式构建Java知识体系，另外在问答中提供技术博客的支撑，更具体的解析和剖析内部深度知识点，做一个有深度的问答总结集。内容包括Java基础知识、JVM、Spring、Spring Cloud &amp;&amp; Spring Cloud Alibaba、Mybatis、Spring Boot、Mybatis、Redis、MySQL等等。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java问答知识总结篇-Redis | 程序猿洞晓</title>
    <link rel="icon" type="image/jpeg" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/favicon.jpg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/matery.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/my.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/reward.css">
    



    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">程序猿洞晓</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/top" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/toolbox" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具箱</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-link" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">程序猿洞晓</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/top" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/toolbox" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具箱
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-link"></i>
			
			友链
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java问答知识总结篇-Redis</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-category">
                                最佳实践
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布时间:&nbsp;&nbsp;
                    2022-09-21
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    29.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    105 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p><a href="/2022/09/interview-java-core-base/">Java问答知识总结篇-基础知识</a><br><a href="/2022/09/interview-java-core-jvm/">Java问答知识总结篇-JVM</a><br><a href="/2022/09/interview-java-core-threads/">Java问答知识总结篇-多线程&amp;并发编程</a><br><a href="/2022/09/interview-java-core-network/">Java问答知识总结篇-网络基础</a><br><a href="/2022/09/interview-java-core-spring/">Java问答知识总结篇-Spring</a><br><a href="/2022/09/interview-java-core-springboot/">Java问答知识总结篇-Spring Boot</a><br><a href="/2022/09/interview-java-core-mybatis/">Java问答知识总结篇-Mybatis</a><br><a href="/2022/09/interview-java-core-mysql/">Java问答知识总结篇-MySQL</a><br><a href="/2022/09/interview-java-core-redis/">Java问答知识总结篇-Redis</a><br><a href="/2022/09/interview-java-core-mq/">Java问答知识总结篇-MQ</a><br><a href="/2022/09/interview-java-core-nginx/">Java问答知识总结篇-Nginx</a><br><a href="/2022/09/interview-java-core-distribution/">Java问答知识总结篇-分布式</a><br><a href="/2022/09/interview-java-core-springcloud/">Java问答知识总结篇-Spring Cloud</a><br><a href="/2022/09/interview-java-core-dubbo/">Java问答知识总结篇-Dubbo</a><br><a href="/2022/09/interview-java-core-zookeeper/">Java问答知识总结篇-Zookeeper</a><br><a href="/2022/09/interview-java-core-elasticsearch/">Java问答知识总结篇-ElasticSearch</a><br><a href="/2022/09/interview-java-core-netty/">Java问答知识总结篇-Netty</a><br><a href="/2022/09/interview-java-core-application/">Java问答知识总结篇-场景分析题</a></p>
</blockquote>
<p>Redis系列文章：<a href="/categories/Redis/">Redis</a></p>
<h2 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h2><p>使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。 Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。</p>
<h2 id="为什么要用-Redis-做缓存？"><a href="#为什么要用-Redis-做缓存？" class="headerlink" title="为什么要用 Redis 做缓存？"></a>为什么要用 Redis 做缓存？</h2><p><strong>从高并发上来说：</strong></p>
<ul>
<li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li>
</ul>
<p><strong>从高性能上来说：</strong></p>
<ul>
<li>用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。</li>
</ul>
<h2 id="使用-Redis-有哪些优缺点"><a href="#使用-Redis-有哪些优缺点" class="headerlink" title="使用 Redis 有哪些优缺点"></a>使用 Redis 有哪些优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务， Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe， 通知， key 过期等特性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
</ul>
<h2 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h2><p>Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（geospatial ）索引半径查询等功能。</p>
<p>它内置了复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、事务（Transactions）和不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和集群（Cluster）保证缓存的高可用性（High availability）。</p>
<p>Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value 数据库。</p>
<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul>
<li><p>内存存储：Redis是使用内存(in-memeroy)存储，没有磁盘IO上的开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。</p>
</li>
<li><p>单线程实现（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</p>
</li>
<li><p>非阻塞IO：Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p>
</li>
<li><p>优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。</p>
</li>
<li><p>使用底层模型不同：Redis直接自己构建了 VM (虚拟内存)机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
<blockquote>
<p>Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p>
<p>Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。<strong>需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="为什么使用-Redis-而不是用-Memcache-呢"><a href="#为什么使用-Redis-而不是用-Memcache-呢" class="headerlink" title="为什么使用 Redis 而不是用 Memcache 呢"></a>为什么使用 Redis 而不是用 Memcache 呢</h2><p>这时候肯定想到的就是做一个 Memcache 与 Redis 区别。</p>
<ul>
<li>Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。不过 Memcache 还可用于缓存其他东西，例如图片、视频等等。</li>
<li>Memcache 仅支持key-value结构的数据类型，Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li>虚拟内存– Redis 当物理内存用完时，可以将一些很久没用到的value 交换到磁盘。</li>
<li>分布式–设定 Memcache 集群，利用 magent 做一主多从; Redis 可以做一主多从。都可以一主一从。</li>
<li>存储数据安全– Memcache 挂掉后，数据没了； Redis 可以定期保存到磁盘（持久化）</li>
<li>Memcache 的单个value最大 1m ， Redis 的单个value最大 512m 。</li>
<li>灾难恢复– Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以通过 aof 恢复</li>
<li>Redis 原生就支持集群模式， Redis3.0 版本中，官方便能支持Cluster模式了， Memcached 没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。</li>
<li>Memcached 网络IO模型是多线程，非阻塞IO复用的网络模型，原型上接近于 nignx 。而 Redis使用单线程的IO复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现类epoll，kqueue 和 select ，更接近于Apache早期的模式。</li>
</ul>
<h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<p><strong>对比:</strong></p>
<ul>
<li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；</li>
<li>Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；</li>
<li>Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；</li>
<li>Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；</li>
<li>Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；</li>
<li>Redis可单独部署，多个项目之间可以共享，本地内存无法共享；</li>
<li>Redis有专门的管理工具可以查看缓存数据。</li>
</ul>
<h2 id="6-Redis的常用场景有哪些"><a href="#6-Redis的常用场景有哪些" class="headerlink" title="6. Redis的常用场景有哪些?"></a>6. Redis的常用场景有哪些?</h2><ol>
<li>缓存</li>
</ol>
<p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p>
<ol start="2">
<li>排行榜</li>
</ol>
<p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>
<ol start="3">
<li>计数器</li>
</ol>
<p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>
<ol start="4">
<li>分布式会话</li>
</ol>
<p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p>
<ol start="5">
<li>分布式锁</li>
</ol>
<p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>
<ol start="6">
<li>社交网络</li>
</ol>
<p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</p>
<ol start="7">
<li>最新列表</li>
</ol>
<p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>
<ol start="8">
<li>消息系统</li>
</ol>
<p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>
<h2 id="为什么-Redis-单线程模型效率也能那么高"><a href="#为什么-Redis-单线程模型效率也能那么高" class="headerlink" title="为什么 Redis 单线程模型效率也能那么高"></a>为什么 Redis 单线程模型效率也能那么高</h2><ul>
<li>C语言实现，效率高</li>
<li>纯内存操作</li>
<li>基于非阻塞的IO复用模型机制</li>
<li>单线程的话就能避免多线程的频繁上下文切换问题</li>
<li>丰富的数据结构（全程采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如亚索表，跳表等）</li>
</ul>
<h2 id="说说-Redis-的线程模型"><a href="#说说-Redis-的线程模型" class="headerlink" title="说说 Redis 的线程模型"></a>说说 Redis 的线程模型</h2><p>Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket；</li>
<li>IO 多路复用程序；</li>
<li>文件事件分派器；</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 Redis 的一次通信过程：</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images/9613348194327893.png"></p>
<p>下面来大致说一下这个图：</p>
<ul>
<li>客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 Socket01，并将该 Socket01 的 AE_READABLE 事件与命令请求处理器关联。</li>
<li>假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 Socket01 会产生AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 Socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Socket01 的 set key value 并在自己内存中完成 set key value 的设置。操作完成后，它会将 Socket01 的 AE_WRITABLE 事件与令回复处理器关联。</li>
<li>如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 Socket01 输入本次操作的一个结果，比如 ok ，之后解除 Socket01 的AE_WRITABLE 事件与命令回复处理器的关联。</li>
</ul>
<p>这样便完成了一次通信。 不要怕这段文字，结合图看，一遍不行两遍，实在不行可以网上查点资料结合着看，一定要搞清楚，否则前面吹的牛逼就白费了。</p>
<h2 id="为什么-Redis-需要把所有数据放到内存中"><a href="#为什么-Redis-需要把所有数据放到内存中" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中"></a>为什么 Redis 需要把所有数据放到内存中</h2><p>Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 I/O 会严重影响 Redis 的性能。而且 Redis 还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，Redis 的使用也被应用得越来越多，使得它拥有很大的优势。</p>
<h2 id="Redis-的同步机制了解是什么"><a href="#Redis-的同步机制了解是什么" class="headerlink" title="Redis 的同步机制了解是什么"></a>Redis 的同步机制了解是什么</h2><p>Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区，等 RDB 文件全部同步到复制节点，复制节点接受完成后将RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p>
<h2 id="pipeline-有什么好处，为什么要用-pipeline"><a href="#pipeline-有什么好处，为什么要用-pipeline" class="headerlink" title="pipeline 有什么好处，为什么要用 pipeline"></a>pipeline 有什么好处，为什么要用 pipeline</h2><p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。<br>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p>
<h2 id="说一下-Redis-有什么优点和缺点"><a href="#说一下-Redis-有什么优点和缺点" class="headerlink" title="说一下 Redis 有什么优点和缺点"></a>说一下 Redis 有什么优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>速度快：因为数据存在内存中，类似于 HashMap ， HashMap 的优势就是查找和操作的时间复杂度都是O(1) 。</li>
<li>支持丰富的数据结构：支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</li>
<li>持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</li>
<li>高可用：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</li>
<li>丰富的特性：Key过期、计数、分布式锁、消息队列等。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li>
<li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， Redis不能提供服务。</li>
</ul>
<h2 id="Redis-缓存刷新策略有哪些"><a href="#Redis-缓存刷新策略有哪些" class="headerlink" title="Redis 缓存刷新策略有哪些"></a>Redis 缓存刷新策略有哪些</h2><p><img src="https://raw.githubusercontent.com/itcrud/images/main/images/9463971231467479.png"></p>
<h2 id="Redis-持久化方式有哪些？以及有什么区别"><a href="#Redis-持久化方式有哪些？以及有什么区别" class="headerlink" title="Redis 持久化方式有哪些？以及有什么区别"></a>Redis 持久化方式有哪些？以及有什么区别</h2><p>Redis 提供两种持久化机制 RDB 和 AOF 机制。</p>
<h3 id="RDB-持久化方式"><a href="#RDB-持久化方式" class="headerlink" title="RDB 持久化方式"></a>RDB 持久化方式</h3><p>是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>只有一个文件 dump.rdb ，方便持久化。</li>
<li>容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能)。</li>
<li>相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</p>
<h3 id="AOF（Append-only-file）-持久化方式"><a href="#AOF（Append-only-file）-持久化方式" class="headerlink" title="AOF（Append-only file） 持久化方式"></a>AOF（Append-only file） 持久化方式</h3><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。<ul>
<li>每修改同步：<code>appendfsync always</code> 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>
<li>每秒同步：<code>appendfsync everysec</code> 异步操作，每秒记录，如果一秒内宕机，有数据丢失</li>
<li>不同步：<code>appendfsync no</code>   从不同步</li>
</ul>
</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。 AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall)。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>相同数据集的数据而言,AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>数据集大的时候，比 RDB 启动效率低。</li>
</ul>
<h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><ul>
<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。</li>
<li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。</li>
<li>如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。</li>
<li>不要仅仅使用RDB，因为那样会导致你丢失很多数据。</li>
<li>也不要仅仅使用AOF，因为那样有两个问题<ul>
<li>第一，你通过AOF做冷备没有RDB做冷备的恢复速度更快; </li>
<li>第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</li>
</ul>
</li>
<li>Redis支持同时开启开启两种持久化方式，我们可以综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在 AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</li>
<li>如果同时使用RDB和AOF两种持久化机制，那么在Redis 启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。</li>
</ul>
<p><strong>补充：Redis4.0 对于持久化机制的优化</strong></p>
<p>Redis4.0相对与3.X版本其中一个比较大的变化是4.0添加了新的混合持久化方式。</p>
<p>简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据，如下图：</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/1075473-20180726181756270-1907770368.png"></p>
<p><strong>优势：</strong> 混合持久化结合了RDB持久化 和 AOF 持久化的优点， 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。</p>
<p><strong>劣势：</strong> 兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差。</p>
<h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><ul>
<li><p>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>
</li>
<li><p>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p>
</li>
</ul>
<h2 id="Redis过期键的删除策略"><a href="#Redis过期键的删除策略" class="headerlink" title="Redis过期键的删除策略"></a>Redis过期键的删除策略</h2><p><strong>Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。</strong></p>
<p><strong>惰性删除：</strong> 惰性删除不会去主动删除数据，而是在访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。它的优点是简单，不需要对过期的数据做额外的处理，只有在每次访问的时候才会检查键值是否过期，缺点是删除过期键不及时，造成了一定的空间浪费。</p>
<p><strong>定期删除：</strong> Redis会周期性的随机测试一批设置了过期时间的key并进行处理。测试到的已过期的key将被删除。</p>
<p>附：删除key常见的三种处理方式。</p>
<ol>
<li>定时删除</li>
</ol>
<p>在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p>
<p><strong>优点：</strong>定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。</p>
<p><strong>缺点：</strong>对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p>
<ol start="2">
<li>惰性删除</li>
</ol>
<p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p>
<p><strong>优点：</strong>对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>
<p><strong>缺点：</strong>对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</p>
<ol start="3">
<li>定期删除</li>
</ol>
<p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p>
<p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>
<p><strong>缺点：</strong>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p>
<h2 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h2><p>Redis是不断的删除一些过期数据，但是很多没有设置过期时间的数据也会越来越多，那么Redis内存不够用的时候是怎么处理的呢？答案就是淘汰策略。此类的</p>
<p>当Redis的内存超过最大允许的内存之后，Redis会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器的正常运行。</p>
<p><strong>Redisv4.0前提供 6种数据淘汰策略</strong></p>
<ul>
<li>volatile-lru：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ </li>
</ul>
<p><strong>Redisv4.0后增加以下两种</strong></p>
<ul>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li>
</ul>
<p>内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。</p>
<h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><blockquote>
<p>背景：使用到缓存，无论是本地内存做缓存还是使用 Redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p>
</blockquote>
<p>共有四种方案：</p>
<ol>
<li>先更新数据库，后更新缓存</li>
<li>先更新缓存，后更新数据库</li>
<li>先删除缓存，后更新数据库</li>
<li>先更新数据库，后删除缓存</li>
</ol>
<p>第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</p>
<p>第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>
<p>目前主要用第三和第四种方案。</p>
<h2 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h2><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<h3 id="答案一：延时双删"><a href="#答案一：延时双删" class="headerlink" title="答案一：延时双删"></a>答案一：延时双删</h3><p>最简单的解决办法延时双删</p>
<p>使用伪代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>转化为中文描述如下：</p>
<ol>
<li>先淘汰缓存</li>
<li>再写数据库（这两步和原来一样）</li>
<li>休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。</li>
</ol>
<p>如果使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/1735bb5881bbb1d4%7Etplv-t2oaga2asx-watermark.awebp"></p>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 更新操作，删除了 Redis</li>
<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>
<li>请 B 查询操作，发现 Redis 中没有数据</li>
<li>去从库中拿去数据</li>
<li>此时同步数据还未完成，拿到的数据是旧数据</li>
</ol>
<p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/1735bb5881a19fec%7Etplv-t2oaga2asx-watermark.awebp"></p>
<h3 id="答案二：-更新与读取操作进行异步串行化"><a href="#答案二：-更新与读取操作进行异步串行化" class="headerlink" title="答案二： 更新与读取操作进行异步串行化"></a>答案二： 更新与读取操作进行异步串行化</h3><p>采用<strong>更新与读取操作进行异步串行化</strong></p>
<p><strong>异步串行化</strong></p>
<p>我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p>
<p>这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</p>
<p><strong>读操作去重</strong></p>
<p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p>
<h2 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h2><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/1735bb5881fb4a1b%7Etplv-t2oaga2asx-watermark.awebp"></p>
<p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/1735bb588215b298%7Etplv-t2oaga2asx-watermark.awebp"></p>
<h2 id="怎么使用-Redis-实现消息队列"><a href="#怎么使用-Redis-实现消息队列" class="headerlink" title="怎么使用 Redis 实现消息队列"></a>怎么使用 Redis 实现消息队列</h2><p>一般使用 list 结构作为队列， rpush 生产消息， lpop 消费消息。当 lpop 没有消息的时候，要适当sleep 一会再重试。</p>
<ul>
<li>面试官可能会问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li>
<li>面试官可能还问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N的消息队列。</li>
<li>面试官可能还问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li>
<li>面试官可能还问 Redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li>
</ul>
<h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis的事务并不是我们传统意义上理解的事务，我们都知道 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis <strong>事务的执行并不是原子性的</strong>。</p>
<p>事务可以理解为一个<strong>打包的批量执行脚本</strong>，但<strong>批量指令并非原子化</strong>的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<p><strong>总结：</strong></p>
<ol>
<li><p>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。<strong>鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的</strong>。</p>
</li>
<li><p>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p>
</li>
</ol>
<blockquote>
<p> 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的Redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p>
</blockquote>
<h2 id="说说你对Redis事务的理解"><a href="#说说你对Redis事务的理解" class="headerlink" title="说说你对Redis事务的理解"></a>说说你对Redis事务的理解</h2><h3 id="什么是-Redis-事务？原理是什么？"><a href="#什么是-Redis-事务？原理是什么？" class="headerlink" title="什么是 Redis 事务？原理是什么？"></a>什么是 Redis 事务？原理是什么？</h3><p>Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。</p>
<p>它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。</p>
<h3 id="Redis-事务的注意点有哪些？"><a href="#Redis-事务的注意点有哪些？" class="headerlink" title="Redis 事务的注意点有哪些？"></a>Redis 事务的注意点有哪些？</h3><ul>
<li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</li>
<li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</li>
</ul>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗?"></a>Redis事务支持隔离性吗?</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h3 id="Redis-事务为什么不支持回滚？"><a href="#Redis-事务为什么不支持回滚？" class="headerlink" title="Redis 事务为什么不支持回滚？"></a>Redis 事务为什么不支持回滚？</h3><ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中.</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<h3 id="Redis事务命令和特点"><a href="#Redis事务命令和特点" class="headerlink" title="Redis事务命令和特点"></a>Redis事务命令和特点</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li>redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li>
<li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li>
<li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li>
</ol>
<h3 id="Redis事务执行流程"><a href="#Redis事务执行流程" class="headerlink" title="Redis事务执行流程"></a>Redis事务执行流程</h3><ol>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队。</p>
<h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li>
</ul>
<h2 id="Redis为何选择单线程？"><a href="#Redis为何选择单线程？" class="headerlink" title="Redis为何选择单线程？"></a>Redis为何选择单线程？</h2><p>在Redis 6.0以前，Redis的核心网络模型选择用单线程来实现。先来看下官方的回答：</p>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis， as usually Redisis either memory or network bound. For instance， using pipelining Redisrunning on an average Linux system can deliver even 1 million requests per second， so if your application mainly uses O(N) or O(log(N)) commands， it is hardly going to use too much CPU.</p>
</blockquote>
<p>核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis的话，如果不考虑 RDB/AOF 等持久化方案，Redis是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。</p>
<p>实际上更加具体的选择单线程的原因如下：</p>
<ul>
<li>避免过多的上下文切换开销：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。</li>
<li>避免同步机制的开销：如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。</li>
<li>简单可维护：如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。</li>
</ul>
<p>总而言之，Redis选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。</p>
<h2 id="Redis真的是单线程？"><a href="#Redis真的是单线程？" class="headerlink" title="Redis真的是单线程？"></a>Redis真的是单线程？</h2><p>讨论 这个问题前，先看下 Redis的版本中两个重要的节点：</p>
<ol>
<li>Redisv4.0（引入多线程处理异步任务）</li>
<li>Redis 6.0（在网络模型中实现多线程 I/O ）</li>
</ol>
<p>所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。</p>
<p>且Redis6.0引入<strong>多线程I/O</strong>，只是用来<strong>处理网络数据的读写和协议的解析</strong>，而<strong>执行命令依旧是单线程</strong>。</p>
<blockquote>
<p>Redis在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。</p>
<p>在 Redisv4.0 之后增加了一些的非阻塞命令如 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code>、<code>FLUSHDB ASYNC</code>。</p>
</blockquote>
<h2 id="Redis-6-0为何引入多线程？"><a href="#Redis-6-0为何引入多线程？" class="headerlink" title="Redis 6.0为何引入多线程？"></a>Redis 6.0为何引入多线程？</h2><p>很简单，就是 Redis的网络 I/O 瓶颈已经越来越明显了。</p>
<p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis的性能有两个方向：</p>
<ul>
<li>优化网络 I/O 模块</li>
<li>提高机器内存读写的速度</li>
</ul>
<p>后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：</p>
<ul>
<li>零拷贝技术或者 DPDK 技术</li>
<li>利用多核优势</li>
</ul>
<p>零拷贝技术有其局限性，无法完全适配 Redis这一类复杂的网络 I/O 场景，更多网络 I/O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。</p>
<p>总结起来，Redis支持多线程主要就是两个原因：</p>
<ul>
<li><p>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</p>
</li>
<li><p>多线程任务可以分摊 Redis 同步 IO 读写负荷</p>
</li>
</ul>
<h2 id="Redis-6-0-采用多线程后，性能的提升效果如何？"><a href="#Redis-6-0-采用多线程后，性能的提升效果如何？" class="headerlink" title="Redis 6.0 采用多线程后，性能的提升效果如何？"></a>Redis 6.0 采用多线程后，性能的提升效果如何？</h2><p>Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。</p>
<p>国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET/SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了。</p>
<h2 id="介绍下Redis的线程模型"><a href="#介绍下Redis的线程模型" class="headerlink" title="介绍下Redis的线程模型"></a>介绍下Redis的线程模型</h2><p>Redis的线程模型包括Redis 6.0之前和Redis 6.0。</p>
<p>下面介绍的是Redis 6.0之前。</p>
<p>Redis 是基于 reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器（file event handler）。由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。</p>
<blockquote>
<p>IO多路复用是 IO 模型的一种，有时也称为异步阻塞 IO，是基于经典的 Reactor 设计模式设计的。多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。</p>
<p>Epoll 是最新的也是目前最好的多路复用技术。</p>
</blockquote>
<p>模型如下图：</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/202105092153018231.png"></p>
<p>文件事件处理器的结构包含了四个部分：</p>
<ul>
<li>多个 Socket。Socket 会产生 AE_READABLE 和 AE_WRITABLE 事件：<ul>
<li>当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件</li>
<li>当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE 事件。</li>
</ul>
</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器。事件处理器包括：连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件：<ul>
<li>如果是客户端要连接 Redis，那么会为 socket 关联连接应答处理器</li>
<li>如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联命令请求处理器</li>
<li>如果是客户端要从 Redis 读数据，那么会为 socket 关联命令回复处理器</li>
</ul>
</li>
</ul>
<p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p>
<p>下图是客户端与 Redis 通信的一次完整的流程：</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/202105092153019692.png"></p>
<ol>
<li>Redis 启动初始化的时候，Redis 会将连接应答处理器与 AE_READABLE 事件关联起来。</li>
<li>如果一个客户端跟 Redis 发起连接，此时 Redis 会产生一个 AE_READABLE 事件，由于开始之初 AE_READABLE 是与连接应答处理器关联，所以由连接应答处理器来处理该事件，这时连接应答处理器会与客户端建立连接，创建客户端响应的 socket，同时将这个 socket 的 AE_READABLE 事件与命令请求处理器关联起来。</li>
<li>如果这个时间客户端向 Redis 发送一个命令（set k1 v1），这时 socket 会产生一个 AE_READABLE 事件，IO 多路复用程序会将该事件压入队列中，此时事件分派器从队列中取得该事件，由于该 socket 的 AE_READABLE 事件已经和命令请求处理器关联了，因此事件分派器会将该事件交给命令请求处理器处理，命令请求处理器读取事件中的命令并完成。操作完成后，Redis 会将该 socket 的 AE_WRITABLE 事件与命令回复处理器关联。</li>
<li>如果客户端已经准备好接受数据后，Redis 中的该 socket 会产生一个 AE_WRITABLE 事件，同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器，由该命令回复处理器将准备好的响应数据写入 socket 中，供客户端读取。</li>
<li>命令回复处理器写完后，就会删除该 socket 的 AE_WRITABLE 事件与命令回复处理器的关联关系。</li>
</ol>
<h2 id="Redis-6-0-多线程的实现机制？"><a href="#Redis-6-0-多线程的实现机制？" class="headerlink" title="Redis 6.0 多线程的实现机制？"></a>Redis 6.0 多线程的实现机制？</h2><p><strong>流程简述如下：</strong></p>
<ul>
<li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li>
<li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li>
<li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li>
<li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li>
<li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210828175543973.png"></p>
<p><strong>该设计有如下特点：</strong></p>
<ul>
<li>IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。</li>
<li>IO 线程只负责读写 Socket 解析命令，不负责命令处理。</li>
</ul>
<h2 id="Redis-6-0开启多线程后，是否会存在线程并发安全问题？"><a href="#Redis-6-0开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="Redis 6.0开启多线程后，是否会存在线程并发安全问题？"></a>Redis 6.0开启多线程后，是否会存在线程并发安全问题？</h2><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>
<p>所以我们不需要去考虑控制 Key、Lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。</p>
<h2 id="Redis-6-0-与-Memcached-多线程模型的对比"><a href="#Redis-6-0-与-Memcached-多线程模型的对比" class="headerlink" title="Redis 6.0 与 Memcached 多线程模型的对比"></a>Redis 6.0 与 Memcached 多线程模型的对比</h2><ul>
<li><p><strong>相同点：</strong>都采用了 Master 线程 -Worker 线程的模型。</p>
</li>
<li><p><strong>不同点：</strong>Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。</p>
<p>而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p>
</li>
</ul>
<h2 id="什么是-bigkey？会存在什么影响？"><a href="#什么是-bigkey？会存在什么影响？" class="headerlink" title="什么是 bigkey？会存在什么影响？"></a>什么是 bigkey？会存在什么影响？</h2><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p>
<p>bigkey 的主要影响有：</p>
<ul>
<li>网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。</li>
<li>超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</li>
<li>导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响。</li>
</ul>
<h2 id="36-Redis常见使用方式有哪些？"><a href="#36-Redis常见使用方式有哪些？" class="headerlink" title="36. Redis常见使用方式有哪些？"></a>36. Redis常见使用方式有哪些？</h2><p>Redis的几种常见使用方式包括：</p>
<ul>
<li> Redis单副本；</li>
<li> Redis多副本（主从）；</li>
<li> Redis Sentinel（哨兵）；</li>
<li> Redis Cluster；</li>
<li> Redis自研。</li>
</ul>
<p>使用场景：</p>
<p><strong>Redis单副本：</strong>如果数据量很少，主要是承载高并发高性能的场景，比如缓存一般就几个G的话，单机足够了。</p>
<p><strong>主从模式：</strong>master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p>
<p><strong>哨兵模式：</strong>master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>
<p><strong>Redis cluster：</strong>主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有master的容量总和就是Redis cluster可缓存的数据容量。</p>
<h2 id="熟悉哪些-Redis-集群模式"><a href="#熟悉哪些-Redis-集群模式" class="headerlink" title="熟悉哪些 Redis 集群模式"></a>熟悉哪些 Redis 集群模式</h2><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>Redis 官方提供的集群化方案，体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p>
<h3 id="Twemprox"><a href="#Twemprox" class="headerlink" title="Twemprox"></a>Twemprox</h3><p>Twemprox 是 Twtter 开源的一个 Redis 和 Memcached 代理服务器，主要用于管理 Redis 和Memcached 集群，减少与Cache 服务器直接连接的数量。</p>
<h3 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h3><p>Codis 是一个代理中间件，当客户端向 Codis 发送指令时， Codis 负责将指令转发到后面的Redis 来执行，并将结果返回给客户端。一个 Codis 实例可以连接多个 Redis 实例，也可以启动多个 Codis 实例来支撑，每个 Codis 节点都是对等的，这样可以增加整体的 QPS 需求，还能起到容灾功能。</p>
<h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><p>在 Redis Cluster 还没出现之前使用较多，现在基本很少热你使用了，在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<h2 id="是否使用过-Redis-Cluster-集群，集群的原理是什么"><a href="#是否使用过-Redis-Cluster-集群，集群的原理是什么" class="headerlink" title="是否使用过 Redis Cluster 集群，集群的原理是什么"></a>是否使用过 Redis Cluster 集群，集群的原理是什么</h2><p>使用过 Redis 集群，它的原理是：</p>
<ul>
<li>所有的节点相互连接；</li>
<li>集群消息通信通过集群总线通信，集群总线端口大小为客户端服务端口 + 10000（固定值）；</li>
<li>节点与节点之间通过二进制协议进行通信；</li>
<li>客户端和集群节点之间通信和通常一样，通过文本协议进行；</li>
<li>集群节点不会代理查询；</li>
<li>数据按照 Slot 存储分布在多个 Redis 实例上；</li>
<li>集群节点挂掉会自动故障转移；</li>
<li>可以相对平滑扩/缩容节点。</li>
</ul>
<p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0~16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>
<h2 id="介绍下Redis单副本"><a href="#介绍下Redis单副本" class="headerlink" title="介绍下Redis单副本"></a>介绍下Redis单副本</h2><p>Redis单副本，采用单个Redis节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829103307048.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>架构简单，部署方便；</li>
<li>高性价比：缓存使用时无需备用节点（单实例可用性可以用supervisor或crontab保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</li>
<li>高性能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不保证数据的可靠性；</li>
<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</li>
<li>高性能受限于单核CPU的处理能力（Redis是单线程机制），CPU为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用Memcached替代。</li>
</ul>
<h2 id="介绍下Redis多副本（主从）"><a href="#介绍下Redis多副本（主从）" class="headerlink" title="介绍下Redis多副本（主从）"></a>介绍下Redis多副本（主从）</h2><p>Redis多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829103327631.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li> 高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</li>
<li> 读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p>
</li>
<li><p>主库的写能力受到单机的限制，可以考虑分片；</p>
</li>
<li><p>主库的存储能力受到单机的限制，可以考虑Pika；</p>
</li>
<li><p>原生复制的弊端在早期的版本中也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p>
</li>
</ul>
<h2 id="介绍下Redis-Sentinel（哨兵）"><a href="#介绍下Redis-Sentinel（哨兵）" class="headerlink" title="介绍下Redis Sentinel（哨兵）"></a>介绍下Redis Sentinel（哨兵）</h2><blockquote>
<p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。</p>
</blockquote>
<p>Redis Sentinel是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群。</p>
<p>其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829103343110.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>Redis Sentinel集群部署简单；</li>
<li>能够解决Redis主从模式下的高可用切换问题；</li>
<li>很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足Redis大容量或高性能的业务需求；</li>
<li>可以实现一套Sentinel监控一组Redis数据节点或多组数据节点。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>部署相对Redis主从模式要复杂一些，原理理解更繁琐；</li>
<li>资源浪费，Redis数据节点中slave节点作为备份节点不提供服务；</li>
<li>Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。</li>
<li>不能解决读写分离问题，实现起来相对复杂。</li>
</ul>
<h2 id="介绍下Redis-Cluster"><a href="#介绍下Redis-Cluster" class="headerlink" title="介绍下Redis Cluster"></a>介绍下Redis Cluster</h2><blockquote>
<p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 Redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p>
</blockquote>
<p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。</p>
<p>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829103444245.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>无中心架构；</li>
<li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li>
<li>可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</li>
<li>节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</li>
<li>数据通过异步复制，不保证数据的强一致性。</li>
<li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li>
<li>Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</li>
<li>Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。对于映射为不同slot值的Key由于Keys不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</li>
<li>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。</li>
<li>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。</li>
<li>不支持多数据库空间，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</li>
<li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
<li>避免产生hot-key，导致主库节点成为系统的短板。</li>
<li>避免产生big-key，导致网卡撑爆、慢查询等。</li>
<li>重试时间应该大于cluster-node-time时间。</li>
<li>Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</li>
</ul>
<h2 id="介绍下Redis自研"><a href="#介绍下Redis自研" class="headerlink" title="介绍下Redis自研"></a>介绍下Redis自研</h2><p>Redis自研的高可用解决方案，主要体现在配置中心、故障探测和failover的处理机制上，通常需要根据企业业务的实际线上环境来定制化。</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829103426922.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>高可靠性、高可用性；</li>
<li>自主可控性高；</li>
<li>贴切业务实际需求，可缩性好，兼容性好。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现复杂，开发成本高；</li>
<li>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；</li>
<li>维护成本高。</li>
</ul>
<h2 id="Redis高可用方案具体怎么实施？"><a href="#Redis高可用方案具体怎么实施？" class="headerlink" title="Redis高可用方案具体怎么实施？"></a>Redis高可用方案具体怎么实施？</h2><p>使用官方推荐的哨兵(sentinel)机制就能实现，当主节点出现故障时，由Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。它有四个主要功能：</p>
<ul>
<li>集群监控，负责监控Redis master和slave进程是否正常工作。</li>
<li>消息通知，如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移，如果master node挂掉了，会自动转移到slave node上。</li>
<li>配置中心，如果故障转移发生了，通知client客户端新的master地址。</li>
</ul>
<h2 id="了解主从复制的原理吗？"><a href="#了解主从复制的原理吗？" class="headerlink" title="了解主从复制的原理吗？"></a>了解主从复制的原理吗？</h2><ol>
<li>主从架构的核心原理</li>
</ol>
<p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</p>
<p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization</p>
<p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
<p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
<ol start="2">
<li>主从复制的断点续传</li>
</ol>
<p>从Redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p>
<p>master node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p>
<p>但是如果没有找到对应的offset，那么就会执行一次resynchronization</p>
<ol start="3">
<li>无磁盘化复制</li>
</ol>
<p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p>
<p>repl-diskless-sync repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p>
<ol start="4">
<li>过期key处理</li>
</ol>
<p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>
<h2 id="由于主从延迟导致读取到过期数据怎么处理？"><a href="#由于主从延迟导致读取到过期数据怎么处理？" class="headerlink" title="由于主从延迟导致读取到过期数据怎么处理？"></a>由于主从延迟导致读取到过期数据怎么处理？</h2><ol>
<li>通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。</li>
<li>Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。</li>
</ol>
<h2 id="主从复制的过程中如果因为网络原因停止复制了会怎么样？"><a href="#主从复制的过程中如果因为网络原因停止复制了会怎么样？" class="headerlink" title="主从复制的过程中如果因为网络原因停止复制了会怎么样？"></a>主从复制的过程中如果因为网络原因停止复制了会怎么样？</h2><p>如果出现网络故障断开连接了，会自动重连的，从Redis 2.8开始，就支持主从复制的断点续传，可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p>master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
<p>master node会在内存中创建一个<code>backlog</code>，master和slave都会保存一个<code>replica offset</code>，还有一个<code>master id</code>，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制。</p>
<p>但是如果没有找到对应的offset，那么就会执行一次<code>resynchronization</code>全量复制。</p>
<h2 id="Redis主从架构数据会丢失吗，为什么？"><a href="#Redis主从架构数据会丢失吗，为什么？" class="headerlink" title="Redis主从架构数据会丢失吗，为什么？"></a>Redis主从架构数据会丢失吗，为什么？</h2><p>有两种数据丢失的情况：</p>
<ol>
<li>异步复制导致的数据丢失：因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。</li>
<li>脑裂导致的数据丢失：某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。</li>
</ol>
<h2 id="如何解决主从架构数据丢失的问题？"><a href="#如何解决主从架构数据丢失的问题？" class="headerlink" title="如何解决主从架构数据丢失的问题？"></a>如何解决主从架构数据丢失的问题？</h2><p>数据丢失的问题是不可避免的，但是我们可以尽量减少。</p>
<p>在Redis的配置文件里设置参数</p>
<pre class="line-numbers language-none"><code class="language-none">min-slaves-to-write 1
min-slaves-max-lag 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>min-slaves-to-write</code>默认情况下是0，<code>min-slaves-max-lag</code>默认情况下是10。</p>
<p>上面的配置的意思是要求至少有1个slave，数据复制和同步的延迟不能超过10秒。如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。</p>
<p>减小<code>min-slaves-max-lag</code>参数的值，这样就可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往master中写入数据。</p>
<p>那么对于client，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入master来保证数据不丢失；也可以将数据写入kafka消息队列，隔一段时间去消费kafka中的数据。</p>
<h2 id="Redis哨兵是怎么工作的？"><a href="#Redis哨兵是怎么工作的？" class="headerlink" title="Redis哨兵是怎么工作的？"></a>Redis哨兵是怎么工作的？</h2><ol>
<li><p>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p>
</li>
<li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。</p>
</li>
<li><p>如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</p>
</li>
<li><p>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p>
</li>
<li><p>当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 ）。</p>
</li>
<li><p>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
</li>
<li><p>sentinel节点会与其他sentinel节点进行“沟通”，投票选举一个sentinel节点进行故障处理，在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。</p>
</li>
</ol>
<h2 id="故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？"><a href="#故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？" class="headerlink" title="故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？"></a>故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？</h2><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来，会考虑slave的一些信息。</p>
<ul>
<li>跟master断开连接的时长。<br>如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master.</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">( down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>slave优先级。<br>按照slave优先级进行排序，slave priority越低，优先级就越高</p>
</li>
<li><p>复制offset。<br>如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高</p>
</li>
<li><p>run id<br>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</p>
</li>
</ul>
<h2 id="同步配置的时候其他哨兵根据什么更新自己的配置呢？"><a href="#同步配置的时候其他哨兵根据什么更新自己的配置呢？" class="headerlink" title="同步配置的时候其他哨兵根据什么更新自己的配置呢？"></a>同步配置的时候其他哨兵根据什么更新自己的配置呢？</h2><p>执行切换的那个哨兵，会从要切换到的新master（salve-&gt;master）那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。</p>
<p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch 作为新的version号。</p>
<p>这个version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置的。</p>
<h2 id="为什么Redis哨兵集群只有2个节点无法正常工作？"><a href="#为什么Redis哨兵集群只有2个节点无法正常工作？" class="headerlink" title="为什么Redis哨兵集群只有2个节点无法正常工作？"></a>为什么Redis哨兵集群只有2个节点无法正常工作？</h2><p>哨兵集群必须部署2个以上节点。</p>
<p>如果两个哨兵实例，即两个Redis实例，一主一从的模式。</p>
<p>则Redis的配置quorum=1，表示一个哨兵认为master宕机即可认为master已宕机。</p>
<p>但是如果是机器1宕机了，那哨兵1和master都宕机了，虽然哨兵2知道master宕机了，但是这个时候，需要majority，也就是大多数哨兵都是运行的，2个哨兵的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），2个哨兵都运行着，就可以允许执行故障转移。</p>
<p>但此时哨兵1没了就只有1个哨兵了了，此时就没有majority来允许执行故障转移，所以故障转移不会执行。</p>
<h2 id="Redis-cluster中是如何实现数据分布的？这种方式有什么优点？"><a href="#Redis-cluster中是如何实现数据分布的？这种方式有什么优点？" class="headerlink" title="Redis cluster中是如何实现数据分布的？这种方式有什么优点？"></a>Redis cluster中是如何实现数据分布的？这种方式有什么优点？</h2><p>Redis cluster有固定的16384个hash slot（哈希槽），对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot。</p>
<p>Redis cluster中每个master都会持有部分slot（槽），比如有3个master，那么可能每个master持有5000多个hash slot。</p>
<p>hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。每次增加或减少master节点都是对16384取模，而不是根据master数量，这样原本在老的master上的数据不会因master的新增或减少而找不到。并且增加或减少master时Redis cluster移动hash slot的成本是非常低的。</p>
<h2 id="Redis-cluster节点间通信是什么机制？"><a href="#Redis-cluster节点间通信是什么机制？" class="headerlink" title="Redis cluster节点间通信是什么机制？"></a>Redis cluster节点间通信是什么机制？</h2><p>Redis cluster节点间采取gossip协议进行通信，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更之后U不断地i将元数据发送给其他节点让其他节点进行数据变更。</p>
<blockquote>
<p>节点互相之间不断通信，保持整个集群所有节点的数据是完整的。<br>主要交换故障信息、节点的增加和移除、hash slot信息等。</p>
</blockquote>
<p>这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力;</p>
<p>缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。</p>
<h2 id="Redis-Cluster-集群方案什么情况下会导致整个集群不可用"><a href="#Redis-Cluster-集群方案什么情况下会导致整个集群不可用" class="headerlink" title="Redis Cluster 集群方案什么情况下会导致整个集群不可用"></a>Redis Cluster 集群方案什么情况下会导致整个集群不可用</h2><p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。假设集群中有 A、B、C 三个集群节点，不存在复制模式下，每个集群的节点包含的哈希槽如下：</p>
<ul>
<li>节点 A 包含从 0 到 5500 的哈希槽；</li>
<li>节点 B 包含从 5501 到 11000 的哈希槽；</li>
<li>节点 C 包含从 11001 到 16383 的哈希槽。</li>
</ul>
<p>这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用。</p>
<h2 id="Redis-常见性能问题和解决方案有哪些"><a href="#Redis-常见性能问题和解决方案有哪些" class="headerlink" title="Redis 常见性能问题和解决方案有哪些"></a>Redis 常见性能问题和解决方案有哪些</h2><p>Redis 常见性能问题和解决方案如下：</p>
<ul>
<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；</li>
<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li>
<li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li>
<li>尽量避免在压力很大的主库上增加从库；</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</li>
</ul>
<h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p>
<h3 id="使用-keys-命令"><a href="#使用-keys-命令" class="headerlink" title="使用 keys 命令"></a>使用 keys 命令</h3><p>直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。</p>
<h3 id="使用-scan-命令"><a href="#使用-scan-命令" class="headerlink" title="使用 scan 命令"></a>使用 scan 命令</h3><p>scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程，并且查找的数据可能存在重复，需要客户端操作去重。因为 scan 是通过游标方式查询的，所以不会导致Redis 出现假死的问题。Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。scan 在检索的过程中，被删除的元素是不会被查询出来的，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长。</p>
<h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致数据库崩溃，系统出现 502 问题。也有可能同时失效，那一刻不用都访问数据库，压力不够大的话，那么 Redis 会出现短暂的卡顿问题。所以为了预防这种问题的发生，最好给数据的过期时间加一个随机值，让过期时间更加分散。</p>
<h2 id="什么情况下可能会导致-Redis-阻塞"><a href="#什么情况下可能会导致-Redis-阻塞" class="headerlink" title="什么情况下可能会导致 Redis 阻塞"></a>什么情况下可能会导致 Redis 阻塞</h2><p>Redis 产生阻塞的原因主要有内部和外部两个原因导致。</p>
<h3 id="内部原因"><a href="#内部原因" class="headerlink" title="内部原因"></a>内部原因</h3><ul>
<li>如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃；</li>
<li>数据持久化占用资源过多；</li>
<li>对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。</li>
</ul>
<h3 id="外部原因"><a href="#外部原因" class="headerlink" title="外部原因"></a>外部原因</h3><p>外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。</p>
<h2 id="缓存和数据库谁先更新呢"><a href="#缓存和数据库谁先更新呢" class="headerlink" title="缓存和数据库谁先更新呢"></a>缓存和数据库谁先更新呢</h2><p>解决方案：</p>
<ol>
<li>写请求过来，将写请求缓存到缓存队列中，并且开始执行写请求的具体操作（删除缓存中的数据，更新数据库，更新缓存）。</li>
<li>如果在更新数据库过程中，又来了个读请求，将读请求再次存入到缓存队列（可以搞n个队列，采用key的hash值进行队列个数取模hash%n，落到对应的队列中，队列需要保证顺序性）中，顺序性保证等待队列前的写请求执行完成，才会执行读请求之前的写请求删除缓存失败，直接返回，此时数据库中的数据是旧值，并且与缓存中的数据是一致的，不会出现缓存一致性的问题。</li>
<li>写请求删除缓存成功，则更新数据库，如果更新数据库失败，则直接返回，写请求结束，此时数据库中的值依旧是旧值，读请求过来后，发现缓存中没有数据， 则会直接向数据库中请求，同时将数据写入到缓存中，此时也不会出现数据一致性的问题。</li>
<li>更新数据成功之后，再更新缓存，如果此时更新缓存失败，则缓存中没有数据，数据库中是新值 ，写请求结束，此时读请求还是一样，发现缓存中没有数据，同样会从数据库中读取数据，并且存入到缓存中，其实这里不管更新缓存成功还是失败， 都不会出现数据一致性的问题。<br>上面这方案解决了数据不一致的问题，主要是使用了串行化，每次操作进来必须按照顺序进行。如果某个队列元素积压太多，可以针对读请求进行过滤，提示用户刷新页面，重新请求。</li>
</ol>
<p><strong>潜在的问题</strong> ，留给大家自己去想吧，因为这个问题属于发散性。</p>
<p>请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。读请求并发高。热点数据路由问题，导致请求倾斜。</p>
<h2 id="Redis-报内存不足怎么处理"><a href="#Redis-报内存不足怎么处理" class="headerlink" title="Redis 报内存不足怎么处理"></a>Redis 报内存不足怎么处理</h2><ul>
<li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存；</li>
<li>设置缓存淘汰策略，提高内存的使用效率；</li>
<li>使用 Redis 集群模式，提高存储量。</li>
</ul>
<h2 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿?"></a>什么是缓存击穿?</h2><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>
<p>从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>
<p>解决方案：</p>
<ul>
<li><p>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>
</li>
<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>
<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
</ul>
</li>
</ul>
<h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透?"></a>什么是缓存穿透?</h2><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<blockquote>
<p> 缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。</p>
</blockquote>
<p><img src="http://blog-img.coolsen.cn/img/2021013117512340.png" alt="img"></p>
<p>解决方法：</p>
<ul>
<li>将无效的key存放进Redis中：</li>
</ul>
<p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p>
<ul>
<li>使用布隆过滤器：</li>
</ul>
<p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<blockquote>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p>
</blockquote>
<h2 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩?"></a>什么是缓存雪崩?</h2><p>如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>
<p>造成缓存雪崩的关键在于同一时间的大规模的key失效，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。</p>
<p>解决方案：</p>
<p>1、事前：</p>
<ul>
<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，<code>setRedis（Key，value，time + Math.random() * 10000）；</code>，保证数据不会在同一时间大面积失效。</p>
</li>
<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p>
</li>
<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>
<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
</ul>
</li>
<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</p>
</li>
</ul>
<p>2、事中：</p>
<ul>
<li><p>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>
</li>
<li><p>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</p>
</li>
</ul>
<p>3、事后：</p>
<p>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<h2 id="什么是缓存预热"><a href="#什么是缓存预热" class="headerlink" title="什么是缓存预热?"></a>什么是缓存预热?</h2><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>
<p>如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>
<p>缓存预热解决方案：</p>
<ul>
<li><p>数据量不大的时候，工程启动的时候进行加载缓存动作；</p>
</li>
<li><p>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</p>
</li>
<li><p>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</p>
</li>
</ul>
<h2 id="什么是缓存降级？"><a href="#什么是缓存降级？" class="headerlink" title="什么是缓存降级？"></a>什么是缓存降级？</h2><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ul>
<li><p>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
</li>
<li><p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
</li>
<li><p>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
</li>
<li><p>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
</li>
</ul>
<h2 id="什么是缓存更新？"><a href="#什么是缓存更新？" class="headerlink" title="什么是缓存更新？"></a>什么是缓存更新？</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，<br>常见的策略有两种： </p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</li>
</ol>
<h2 id="以参考日志级别设置预案"><a href="#以参考日志级别设置预案" class="headerlink" title="以参考日志级别设置预案"></a>以参考日志级别设置预案</h2><ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="热点数据和冷数据是什么"><a href="#热点数据和冷数据是什么" class="headerlink" title="热点数据和冷数据是什么"></a>热点数据和冷数据是什么</h2><p><strong>热点数据，缓存才有价值</strong>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 <strong>数据更新前至少读取两次</strong>，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h2 id="Redis的数据类型，以及每种数据类型的使用场景"><a href="#Redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis的数据类型，以及每种数据类型的使用场景"></a>Redis的数据类型，以及每种数据类型的使用场景</h2><ol>
<li><strong>String：</strong> 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 </li>
<li><strong>hash：</strong> 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</li>
<li><strong>list：</strong> 使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。 </li>
<li><strong>set：</strong> 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li>
<li><strong>sorted set：</strong> sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</li>
</ol>
<p><strong>三种特殊的数据类型</strong></p>
<ol>
<li><p><strong>Bitmap：</strong>位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p>
</li>
<li><p><strong>Hyperloglog：</strong>HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。</p>
</li>
</ol>
<p>要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>
<ol start="3">
<li><strong>Geospatial：</strong>主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。</li>
</ol>
<h2 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h2><p>redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略? 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 定期删除+惰性删除是如何工作的呢? 定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 在redis.conf中有一行配置（maxmemory-policy volatile-lru）。</p>
<p><strong>内存淘汰策略</strong></p>
<ul>
<li><code>volatile-lru</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰；</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰；</li>
<li><code>volatile-random</code>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰；</li>
<li><code>allkeys-lru</code>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰；</li>
<li><code>allkeys-random</code>：从数据集（server.db[i].dict）中任意选择数据淘汰；</li>
<li><code>no-enviction</code>（驱逐）：禁止驱逐数据，新写入操作会报错。</li>
</ul>
<p>如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 <code>volatile-lru</code>, <code>volatile-random</code> 和 <code>volatile-ttl</code>策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="为什么Redis的操作是原子性的，怎么保证原子性的"><a href="#为什么Redis的操作是原子性的，怎么保证原子性的" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性的"></a>为什么Redis的操作是原子性的，怎么保证原子性的</h2><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。Redis的操作之所以是原子性的，是因为Redis是单线程的。 Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗？ 不一定，将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua的方式实现。</p>
<h2 id="什么是分布式锁？为什么用分布式锁？"><a href="#什么是分布式锁？为什么用分布式锁？" class="headerlink" title="什么是分布式锁？为什么用分布式锁？"></a>什么是分布式锁？为什么用分布式锁？</h2><p>锁在程序中的作用就是同步工具，保证共享资源在同一时刻只能被一个线程访问，Java中的锁我们都很熟悉了，像synchronized 、Lock都是我们经常使用的，但是Java的锁只能保证单机的时候有效，分布式集群环境就无能为力了，这个时候我们就需要用到分布式锁。</p>
<p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源。</p>
<p>思路是：在整个系统提供一个<strong>全局、唯一</strong>的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。</p>
<p>一般来说，分布式锁需要满足的特性有这么几点：</p>
<ol>
<li><p>互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p>
</li>
<li><p>高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p>
</li>
<li><p>防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p>
</li>
<li><p>独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了。</p>
</li>
</ol>
<h2 id="常见的分布式锁有哪些解决方案？"><a href="#常见的分布式锁有哪些解决方案？" class="headerlink" title="常见的分布式锁有哪些解决方案？"></a>常见的分布式锁有哪些解决方案？</h2><p>实现分布式锁目前有三种流行方案，即基于关系型数据库、Redis、ZooKeeper 的方案</p>
<ol>
<li>基于关系型数据库，如MySQL<br>基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
<ol start="2">
<li>基于Redis实现</li>
</ol>
<p>优点：</p>
<p>Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮；</li>
<li>key 的过期时间设置多少不明确，只能根据实际情况调整；</li>
<li>需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<ol start="3">
<li>基于zookeeper</li>
</ol>
<p><strong>优点：</strong></p>
<p>zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</p>
<p><strong>缺点：</strong></p>
<p>在高请求高并发下，系统疯狂的加锁释放锁，最后 zk 承受不住这么大的压力可能会存在宕机的风险。</p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><h3 id="分布式锁流程图"><a href="#分布式锁流程图" class="headerlink" title="分布式锁流程图"></a>分布式锁流程图</h3><p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p>
<h3 id="分布式锁的三个核心要素"><a href="#分布式锁的三个核心要素" class="headerlink" title="分布式锁的三个核心要素"></a>分布式锁的三个核心要素</h3><ol>
<li>加锁</li>
</ol>
<p>使用setnx来加锁。key是锁的唯一标识，按业务来决定命名，value这里设置为test。</p>
<pre class="line-numbers language-none"><code class="language-none">setx key test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败；</p>
<ol start="2">
<li>解锁</li>
</ol>
<p>有加锁就得有解锁。当得到的锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式就是执行del指令。</p>
<pre class="line-numbers language-none"><code class="language-none">del key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>释放锁之后，其他线程就可以继续执行setnx命令来获得锁。</p>
<ol start="3">
<li>锁超时</li>
</ol>
<p>锁超时知道的是：如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程北向进来。</p>
<p>所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一段时间后自动释放。setnx不支持超时参数，所以需要额外指令，</p>
<pre class="line-numbers language-none"><code class="language-none">expire key 30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="上述分布式锁存在的问题"><a href="#上述分布式锁存在的问题" class="headerlink" title="上述分布式锁存在的问题"></a>上述分布式锁存在的问题</h3><p><strong>通过上述<code>setnx</code> 、<code>del</code>和<code>expire</code>实现的分布式锁还是存在着一些问题。</strong></p>
<ol>
<li>SETNX 和 EXPIRE 非原子性</li>
</ol>
<p>假设一个场景中，某一个线程刚执行setnx，成功得到了锁。此时setnx刚执行成功，还未来得及执行expire命令，节点就挂掉了。此时这把锁就没有设置过期时间，别的线程就再也无法获得该锁。</p>
<p><strong>解决措施:</strong></p>
<p>由于<code>setnx</code>指令本身是不支持传入超时时间的，而在Redis2.6.12版本上为<code>set</code>指令增加了可选参数, 用法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">SET key value [EX seconds][PX milliseconds] [NX|XX]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>EX second: 设置键的过期时间为second秒；</li>
<li>PX millisecond：设置键的过期时间为millisecond毫秒；</li>
<li>NX：只在键不存在时，才对键进行设置操作；</li>
<li>XX：只在键已经存在时，才对键进行设置操作；</li>
<li>SET操作完成时，返回OK，否则返回nil。</li>
</ul>
<ol start="2">
<li>锁误解除</li>
</ol>
<p>如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。</p>
<p><strong>解决办法：</strong></p>
<p>在del释放锁之前加一个判断，验证当前的锁是不是自己加的锁。</p>
<p>具体在加锁的时候把当前线程的id当做value，可生成一个 UUID 标识当前线程，在删除之前验证key对应的value是不是自己线程的id。</p>
<p>还可以使用 lua 脚本做验证标识和解锁操作。</p>
<ol start="3">
<li>超时解锁导致并发</li>
</ol>
<p>如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。</p>
<p>A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：</p>
<ul>
<li>将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。</li>
<li>为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。</li>
</ul>
<ol start="4">
<li>不可重入</li>
</ol>
<p>当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。</p>
<ol start="5">
<li>无法等待锁释放</li>
</ol>
<p>上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。</p>
<ul>
<li>可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。</li>
<li>另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。</li>
</ul>
<h2 id="了解RedLock吗？"><a href="#了解RedLock吗？" class="headerlink" title="了解RedLock吗？"></a>了解RedLock吗？</h2><p>Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点Redis的分布式锁。</p>
<p>RedLock官方推荐，Redisson完成了对Redlock算法封装。</p>
<p>此种方式具有以下特性：</p>
<ul>
<li>互斥访问：即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li>
<li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li>
</ul>
<h2 id="RedLock的原理"><a href="#RedLock的原理" class="headerlink" title="RedLock的原理"></a>RedLock的原理</h2><p>假设有5个完全独立的Redis主服务器</p>
<ol>
<li><p>获取当前时间戳</p>
</li>
<li><p>client尝试按照顺序使用相同的key,value获取所有Redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的Redis服务。并且试着获取下一个Redis实例。</p>
</li>
</ol>
<p>  比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p>
<ol start="3">
<li><p>client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个Redis实例成功获取锁，才算真正的获取锁成功</p>
</li>
<li><p>如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);</p>
</li>
<li><p>如果客户端由于某些原因获取锁失败，便会开始解锁所有Redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁</p>
</li>
</ol>
<p>算法示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/itcrud/images/main/images2/image-20210829131128229.png"></p>
<h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><ul>
<li><p> <strong>控制key的数量</strong>。当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。</p>
</li>
<li><p><strong>缩减键值对象</strong>。降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。</p>
<ul>
<li>key长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li>
<li>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。</li>
</ul>
</li>
<li><p> <strong>编码优化</strong>。Redis对外提供了string,list,hash,set,zet等类型，但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。</p>
</li>
</ul>
<h2 id="如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？"><a href="#如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？" class="headerlink" title="如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？"></a>如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？</h2><p>如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。</p>
<p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。</p>
<p>如果需要缓存1T+的数据，选择Redis cluster模式，每个主节点存一部分数据，假设一个master存32G，那只需要n*32G&gt;=1T，n个这样的master节点就可以支持1T+的海量数据的存储了。</p>
<blockquote>
<p>Redis单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个slave的数据和master的完全一样。假如master是10G那slave也只能存10G数据。所以数据量受单主的影响。<br>而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis官方给出的 Redis cluster 模式完美的解决了这个问题。</p>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">程序猿洞晓</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://itcrud.github.io/2022/09/interview-java-core-redis/">https://itcrud.github.io/2022/09/interview-java-core-redis/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">程序猿洞晓</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'd5b070018a0674352910',
        clientSecret: 'ee7de87a788f3687fbd8365e86cb2ba43f20c0a9',
        repo: 'issue',
        owner: 'itcrud',
        admin: ["itcrud"],
        id: '2022-09-21T15-04-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/09/interview-java-core-distribution/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="Java问答知识总结篇-分布式">
                        
                        <span class="card-title">Java问答知识总结篇-分布式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            以问答的方式构建Java知识体系，另外在问答中提供技术博客的支撑，更具体的解析和剖析内部深度知识点，做一个有深度的问答总结集。内容包括Java基础知识、JVM、Spring、Spring Cloud && Spring Cloud Alibaba、Mybatis、Spring Boot、Mybatis、Redis、MySQL等等。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-category">
                                    最佳实践
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">
                        <span class="chip bg-color">分布式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/09/interview-java-core-zookeeper/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="Java问答知识总结篇-Zookeeper">
                        
                        <span class="card-title">Java问答知识总结篇-Zookeeper</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            以问答的方式构建Java知识体系，另外在问答中提供技术博客的支撑，更具体的解析和剖析内部深度知识点，做一个有深度的问答总结集。内容包括Java基础知识、JVM、Spring、Spring Cloud && Spring Cloud Alibaba、Mybatis、Spring Boot、Mybatis、Redis、MySQL等等。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-category">
                                    最佳实践
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Zookeeper/">
                        <span class="chip bg-color">Zookeeper</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2015-2023</span>
            
            <a href="/about" target="_blank">程序猿洞晓</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">695.5k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2015";
                        var startMonth = "09";
                        var startDate = "1";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/itcrud" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:itcrud@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/itcrud/itcrud.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
